diff --git a/Users/michael/Projects/oss/graph-monitor/data-capture/chartGenerator.js b/Users/michael/Projects/oss/graph-monitor/data-capture/chartGenerator.js
index 1234567..abcdefg 100644
--- a/Users/michael/Projects/oss/graph-monitor/data-capture/chartGenerator.js
+++ b/Users/michael/Projects/oss/graph-monitor/data-capture/chartGenerator.js
@@ -261,6 +261,75 @@
     return format(date, 'MMM dd HH:mm');
   }
 
+  generateTimeLabels(startTime, endTime, source) {
+    const labels = [];
+    let interval;
+    
+    if (source === 'latest') {
+      interval = 60; // 1 minute
+    } else if (source === 'rollup-5m') {
+      interval = 5 * 60; // 5 minutes
+    } else if (source === 'rollup-30m') {
+      interval = 30 * 60; // 30 minutes
+    } else if (source === 'rollup-1h') {
+      interval = 60 * 60; // 1 hour
+    } else if (source === 'rollup-12h') {
+      interval = 12 * 60 * 60; // 12 hours
+    } else if (source === 'rollup-1d') {
+      interval = 24 * 60 * 60; // 1 day
+    } else {
+      interval = 60; // default to 1 minute
+    }
+    
+    // Align start time to interval
+    const alignedStart = Math.floor(startTime / interval) * interval;
+    
+    for (let t = alignedStart; t <= endTime; t += interval) {
+      labels.push(this.formatTimestamp(t));
+    }
+    
+    return labels;
+  }
+
+  parseFormattedTimestamp(formatted) {
+    // This is a simplified reverse of formatTimestamp
+    // In production, we'd want a more robust solution
+    const now = new Date();
+    const today = now.toDateString();
+    
+    // Check if it's today's format (HH:mm)
+    if (formatted.match(/^\d{2}:\d{2}$/)) {
+      const [hours, minutes] = formatted.split(':').map(Number);
+      const date = new Date();
+      date.setHours(hours, minutes, 0, 0);
+      return Math.floor(date.getTime() / 1000);
+    }
+    
+    // Otherwise parse full format (MMM dd HH:mm)
+    // This is a simplified parser - in production use a proper date parser
+    return 0; // Placeholder
+  }
+
+  alignDataToFullTimeRange(values, labels, startTime, endTime) {
+    // Create a map for efficient lookup
+    const valueMap = {};
+    values.forEach(v => {
+      valueMap[v.timestamp] = v.value;
+    });
+    
+    // Generate data points for each label
+    return labels.map(label => {
+      // Find the timestamp that corresponds to this label
+      // This is simplified - in production we'd need proper timestamp parsing
+      for (const v of values) {
+        if (this.formatTimestamp(v.timestamp) === label) {
+          return v.value;
+        }
+      }
+      return null; // No data for this time point
+    });
+  }
+
   getStartTime(limit, now) {
     const units = {
       's': 1,